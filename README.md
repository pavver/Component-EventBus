# EventBus C Library

EventBus — це бібліотека для роботи з патерном **EventBus** на мові програмування C. Вона дозволяє обмінюватися даними між компонентами системи за допомогою подій із забезпеченням потокобезпеки.

## Основні концепції


### Подія

Це "подія" яка відправляєтся в EventBus, може бути як Request так і Message.

- Message
  - **Message** — Додає в EventBus подію яка не потребує очікування або підтвердження обробки.
  - Виклик події **не блокує виконання потоку**.
  - Дані передаються одним з способів:
    1. Як вказівник на існуючі дані.
    2. Через функції:
      - `size_fn` — отримує розмір даних.
      - `read_fn` — читає дані частинами, якщо обсяг великий.

- Request
  - Request схожий на подію, але дозволяє отримувати **вихідні дані**.
  - При виклику Request **контекст виклику блокується** до завершення обробки.
  - Результати обробки Request передаються одним з способів:
    1. Через вказівник на змінну.
    2. Через callback-функцію (можливі багаторазові виклики для передачі великих обсягів даних).

> Подія автоматично очищається після завершення обробки всіма підписниками.

### Фільтрація подій
- **event_type** — це ідентифікатор, який використовується для розрізнення подій. Тип події має розмір `uint8_t` (1 байт), що дозволяє створити до 255 різних типів подій.
- **Тип 0** зарезервований для обробки всіх подій. Події з типом `0` створювати заборонено.

- **event_subtype** уточнює конкретику в межах типу події. Також має розмір `uint8_t` (1 байт).
- **Підтип 0** зарезервований для обробки всіх підтипів. Події з підтипом `0` створювати заборонено.

### Як це працює
При підписці:
- Підписник може обробляти конкретний тип і підтип події, або всі події/підтипи, встановивши відповідно тип і підтип у `0`.

Наприклад:
- Тип: `WiFi`, Підтип: `Connect` — підписник обробляє тільки підключення до WiFi.
- Тип: `WiFi`, Підтип: `0` — підписник обробляє всі події, пов’язані з WiFi.

### Підписник
- **Підписник** обробляє події/команди.
- Дані обробляються:
  1. Через callback-функцію (асинхронно, у потоці EventBus).
  2. Через спеціальну функцію для отримання події (обробка у потоці підписника).
- Якщо подія обробляєтся не через callback-функцію то в налаштуваннях EventBus може бути налаштований timeout після закінчення якого цей обробник події буде пропущено зі статусом **TIMEOUT**
- Пріоритет підписника визначається числом `uint8_t` (0–255).  
  - **Пріоритет 0** — максимальний.
  - **Пріоритет 255** — мінімальний.
  - Якщо підписники мають однаковий пріоритет, першим викликається той, хто зареєструвався раніше.
  - Якщо підписник обробляє подію не через callback-функцію а сам викликає функцію для отримання наступної події, то відповідно якщо у іншого обробника такий самий пріоритет але він обробляє через callback-функцію то інший обробник буде викликаним першим.

Обробники подій повертають статус:
- **OK**.
- **FAIL**.
- **TIMEOUT** (лише для підписників, які не використовують callback і не почали обробку у встановлений час).

### Паблішер
- **Паблішер** створює події та передає їх в EventBus.  
- Якщо було створено та відправлено Request то блокуєтся контекст виконання та очікуєтся відповідь.
  - Можна налаштувати максимальний пріоритет підписників, обробку якими потрібно почекати, після завершення обробки цими підписниками контекст виконання буде розблоковано але виконання події продовжится іншими підписниками (у випадку якщо інші підписники будуть подифікувати вихідні данні можуть бути проблеми тому рекомендуєтся за необхідності відразу скопіювати необхідні данні)

---

## Архітектура

### Зберігання підписників
- Усі підписники зберігаються у загальному масиві.
- При виклику події створюється окремий масив, що містить вказівники лише на підписників, які оброблятимуть цю подію.

### Потокобезпека
- Потокобезпека забезпечується через використання `mutex`.

---

## Особливості
1. **Типи та підтипи подій** забезпечують просту фільтрацію.
2. **Автоматичний життєвий цикл** події — очищення після обробки.
3. **Пріоритетна черга** для підписників.
4. Підтримка **callback-функцій** та **обробки у потоках підписників**.
5. **Розширюваність**: додавання нових типів подій та підписників не впливає на інші компоненти.

---

## Приклад використання

```c
#include "eventbus.h"

// Підписник на всі події WiFi
void wifi_event_handler(event_t *event) {
    printf("WiFi Event Received: Type=%d, Subtype=%d\n", event->type, event->subtype);
    return EVENT_SUCCESS;
}

// Створення події
void publish_wifi_event(eventbus_t *bus) {
    event_t event = {
        .type = WIFI,
        .subtype = CONNECT,
        .data = NULL,
    };
    eventbus_publish(bus, &event);
}

int main() {
    eventbus_t bus;
    eventbus_init(&bus);

    // Реєстрація підписника
    eventbus_subscribe(&bus, WIFI, 0, wifi_event_handler, 0);

    // Виклик події
    publish_wifi_event(&bus);

    eventbus_cleanup(&bus);
    return 0;
}
